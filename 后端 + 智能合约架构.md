# 后端 + 智能合约架构

## A. 后端

### 1. 用户 / 账户（C / R / U）

- **C**
  - 创建用户账号（如果你用 Supabase/Auth0，这块是它们做）
  - 第一次登录时，在你自己的业务库里建一条 `user_profile`
- **R**
  - 获取用户信息：用户名、邮箱、头像、偏好设置
- **U**
  - 修改用户名、邮箱（部分场景）、头像
  - 用户偏好（语言、货币单位、黑暗模式等）
- **D**
  - 软删除账号 / 标记停用（真正删一般不做）

------

### 2. 市场（Market）（C / R / U）

- **C**
  - 管理员创建市场（标题、描述、截止时间、选项 A/B…）
  - 这一步通常是：
    - Web2 先在数据库写一条 `markets`
    - 再调用链上 `createMarket(...)`（由 admin 地址发）
- **R**
  - 列表：分页加载市场
  - 详情：某个市场的详细信息
  - 筛选：按分类、标签、状态（进行中/已结算）
- **U**
  - 管理员修改市场文案（描述、封面图等）
  - 前端排序权重、推荐位（不影响链上）
- **D**
  - 隐藏/下架市场（数据库标记，不物理删除）

------

### 3. 赔率 / K 线 / 市场数据（主要是 R + 内部写）

> 这里是典型的 **Web2 计算层**

- **内部写（不是公开 CRUD，那是你的业务逻辑）**
  - 定时任务或撮合引擎：
    - 计算当前盘口价格 / 隐含概率
    - 生成 1min/5min/1h K 线
    - 把结果写入 `market_stats`, `market_candles` 表
- **R**
  - 获取当前赔率（前端展示）
  - 获取 K 线数据（前端画图）
- **U / D**
  - 一般不用外部 U/D，内部可能有重算/补数据

------

### 4. 下单 / 头寸 / 成交记录（C / R / U）

> 这里是 Web2 和 Web3 有交集的地方

- **C**
  - 创建“下单请求”（还没真正成功）：
     `orders_pending` / `bet_intent`
  - 等链上交易完成后，把结果写入：
    - `positions`（用户在某市场 A/B 持仓）
    - `trades`（流水）
- **R**
  - 查询某用户持仓、历史下注记录
  - 查询某市场的成交记录（用于盘口、深度图）
- **U**
  - 更新订单状态：pending → success / failed
  - 更新本地持仓（基于链上事件同步）
- **D**
  - 取消未发送到链上的本地挂单（如果有）

------

### 5. 评论 / 社区（C / R / U / D）

- **C**
  - 发表评论 / 回复
- **R**
  - 加载某个市场的评论列表
- **U**
  - 用户编辑自己的评论（视产品而定）
- **D**
  - 用户删自己的评论
  - 管理员删违规评论（软删除）

------

### 6. 钱包绑定 / 充值提现日志（C / R）

- **C**
  - 记录一次充值/提现请求
  - 记录对应的链上 tx hash
- **R**
  - 用户查看充值/提现记录
- **U**
  - 根据链上事件更新状态：pending → confirmed / failed



---

## B. 智能合约

### 1. 代币层（Token）

如果你用的是现成稳定币（USDC 等），可以不自己写，直接用已部署的合约。
 如果是自定义赌资 Token，最少要有：

- `ERC20` 标准：
  - `balanceOf`
  - `transfer`
  - `transferFrom`
  - `approve`
- 事件：
  - `Transfer`

------

### 2. 市场合约（PredictionMarket）

基础版建议至少有这些东西：

#### 状态（storage）

```
struct Market {
    uint256 id;
    string  description;      // 也可以只放哈希，详细文案放 Web2
    uint256 closeTime;        // 截止时间
    bool    resolved;         // 是否已结算
    uint8   winningOption;    // 0 = 未决, 1 = A, 2 = B
    uint256 totalYes;         // 选项 A 总筹码
    uint256 totalNo;          // 选项 B 总筹码
}
```

#### 必备方法

- **创建市场（admin 调）**

```
function createMarket(
    string memory description,
    uint256 closeTime
) external onlyOwner;
```

- **用户下注 / 买入份额**

```
function betYes(uint256 marketId, uint256 amount) external;
function betNo(uint256 marketId, uint256 amount) external;
```

> 里边会：
>
> - `transferFrom` 用户的 Token 到合约
> - 记录用户在此市场的持仓

- **结算市场（oracle / 管理员调）**

```
function resolveMarket(uint256 marketId, uint8 winningOption) external onlyOracle;
```

> 这里的 `winningOption` 就是你说的
>  `UNRESOLVED -> OPTION_A / OPTION_B`，
>  **必须在链上存。**

- **用户提取收益**

```
function claim(uint256 marketId) external;
```

------

### 3. 资金流相关

- 合约地址本身持有下注资金
- 用户通过 `claim` 拿回：
  - 本金 + 盈利（如果押对）
- 可能再加：
  - 管理员提取平台手续费
  - 提供流动性的 LP 取回资金（后面版本再说）

------

### 4. 链上事件（Event）（给 Web2 同步用）

基础版建议至少有：

```
event MarketCreated(uint256 indexed id, string description);
event BetPlaced(uint256 indexed id, address indexed user, bool option, uint256 amount);
event MarketResolved(uint256 indexed id, uint8 winningOption);
event PayoutClaimed(uint256 indexed id, address indexed user, uint256 amount);
```

> Web2 后端可以通过监听/索引这些事件，
>  来同步自己的数据库（trades / positions / stats）。